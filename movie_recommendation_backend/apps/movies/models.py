import json
from django.db import models
from django.core.validators import MinValueValidator, MaxValueValidator
from django.core.exceptions import ValidationError
from django.utils.text import slugify
from django.utils import timezone
from django.db.models import F
from datetime import timedelta, date



def validate_json_array(value):
    """
    Custom validator to ensure that the field value is a valid JSON array.
    """
    try:
        data = json.loads(value) if isinstance(value, str) else value
        if not isinstance(data, list):
            raise ValidationError("This field must be a valid JSON array.")
    except (json.JSONDecodeError, TypeError):
        raise ValidationError("This field must be a valid JSON array.")
    
    
class Genre(models.Model):
    """
    This is the custom model  for the movie genres from the TMDB API.
    The ID field will be automatically generated by the database.
    we will have the tmdb_id, name, slug and the created_at timestamp.
    """
    tmdb_id = models.PositiveIntegerField(unique=True, verbose_name="TMDB ID", help_text="The unique ID of the genre from TMDB")
    name = models.CharField(max_length=100, unique=True, verbose_name="Genre Name", help_text="The name of the genre")
    slug = models.SlugField(max_length=100, unique=True, blank=True, editable=False, help_text="A URL-friendly version of the genre name")
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="Created At", help_text="The timestamp when the genre was created")

    class Meta:
        db_table = 'genres'
        verbose_name = "Genre"
        verbose_name_plural = "Genres"
        ordering = ['name']

        # Database indexes for performance optimization
        indexes = [
            models.Index(fields=['tmdb_id'], name='idx_genres_tmdb_id'),
            models.Index(fields=['slug'], name='idx_genres_slug'),
            models.Index(fields=['name'], name='idx_genres_name'),
        ]

    def save(self, *args, **kwargs):
        """
        Override the save method to automatically generate the slug from the name.
        """
        if not self.slug:
            self.slug = slugify(self.name)
        super().save(*args, **kwargs)

    def __str__(self):
        return self.name
    
    def __repr__(self):
        return f"Genre(tmdb_id={self.tmdb_id}, name={self.name}, slug={self.slug})"
    

class Movie(models.Model):
    """
    This is the core movie information model with simplified cast/crew data
    
    """
    tmdb_id = models.PositiveIntegerField(unique=True, verbose_name="TMDB ID", help_text="The unique ID of the movie from TMDB")
    omdb_id = models.CharField(max_length=20, unique=True, null=True, blank=True, verbose_name="OMDB ID", help_text="The unique ID of the movie from OMDB")
    title = models.CharField(max_length=255, verbose_name="Movie Title", help_text="The title of the movie")
    original_title = models.CharField(max_length=255, verbose_name="Original Title", help_text="The original title of the movie")
    tagline = models.CharField(max_length=255, blank=True, verbose_name="Tagline", help_text="A tagline for the movie")
    overview = models.TextField(blank=True, verbose_name="Overview", help_text="A brief overview of the movie")
    release_date = models.DateField(null=True, blank=True, verbose_name="Release Date", help_text="The release date of the movie")
    runtime = models.PositiveIntegerField(null=True, blank=True, verbose_name="Runtime", help_text="The runtime of the movie in minutes")
    director = models.CharField(max_length=255, blank=True, verbose_name="Director", help_text="The director of the movie")
    main_cast = models.JSONField(default=list, validators=[validate_json_array], verbose_name="Main Cast", help_text="List of main cast members")
    # Ratings
    tmdb_rating = models.DecimalField(max_digits=3, decimal_places=1, null=True, blank=True, validators=[MinValueValidator(0), MaxValueValidator(10)], verbose_name="TMDB Rating", help_text="The TMDB rating of the movie")
    tmdb_vote_count = models.PositiveIntegerField(default=0, verbose_name="TMDB Vote Count", help_text="The number of votes for the TMDB rating")
    omdb_rating = models.DecimalField(max_digits=3, decimal_places=1, null=True, blank=True, validators=[MinValueValidator(0), MaxValueValidator(10)], verbose_name="OMDB Rating", help_text="The OMDB rating of the movie")
    our_rating = models.DecimalField(max_digits=3, decimal_places=1, null=True, blank=True, validators=[MinValueValidator(0), MaxValueValidator(10)], verbose_name="Our Rating", help_text="User-generated average rating of the movie")
    # Media Assets
    poster_path = models.CharField(max_length=255, blank=True, verbose_name="Poster Path", help_text="Path to the movie poster image")
    backdrop_path = models.CharField(max_length=255, blank=True, verbose_name="Backdrop Path", help_text="Path to the movie backdrop image")
    # Performance metrics
    popularity_score = models.DecimalField(max_digits=10, decimal_places=2, default=0.0, verbose_name="Popularity", help_text="The popularity score of the movie")
    views = models.PositiveIntegerField(default=0, verbose_name="Views", help_text="The number of views for the movie")
    like_count = models.PositiveIntegerField(default=0, verbose_name="Like Count", help_text="The number of likes for the movie")
    # Adult content flag
    adult = models.BooleanField(default=False, verbose_name="Adult Content", help_text="Indicates if the movie contains adult content")
    # Original language code
    original_language = models.CharField(max_length=10, blank=True, verbose_name="Original Language", help_text="The original language of the movie")
    # Timestamp for creation
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="Created At", help_text="The timestamp when the movie was created")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="Updated At", help_text="The timestamp when the movie was last updated")

    # Relationships
    genres = models.ManyToManyField(Genre, through='MovieGenre', related_name='movies', blank=True, verbose_name="Genres", help_text="The genres associated with the movie")

    class Meta:
        db_table = 'movies'
        verbose_name = "Movie"
        verbose_name_plural = "Movies"
        ordering = ['-release_date', '-popularity_score']

        # Database indexes for performance optimization
        indexes = [
            models.Index(fields=['tmdb_id'], name='idx_movies_tmdb_id'),
            models.Index(fields=['title'], name='idx_movies_title'),
            models.Index(fields=['release_date'], name='idx_movies_release_date'),
            models.Index(fields=['popularity_score'], name='idx_movies_popularity_score'),
            models.Index(fields=['tmdb_rating'], name='idx_movies_tmdb_rating'),
            models.Index(fields=['omdb_rating'], name='idx_movies_omdb_rating'),
            models.Index(fields=['original_language'], name='idx_movies_original_language'),
            models.Index(fields=['adult'], name='idx_movies_adult'),
            models.Index(fields=['created_at'], name='idx_movies_created_at'),
        ]


    # Custom methods and properties
    @property
    def main_cast_list(self):
        try:
            return json.loads(self.main_cast)
        except json.JSONDecodeError:
            return []
        
    def set_main_cast(self, cast_list):
        """
        Set the main cast as a JSON array.
        """
        if isinstance(cast_list, list):
            self.main_cast = json.dumps(cast_list)
        else:
            raise ValueError("main_cast must be a list.")
        
    def add_cast_member(self, actor_name):
        """
        Add a single cast member to the main cast.
        """
        current_cast = self.main_cast_list
        if actor_name not in current_cast:
            current_cast.append(actor_name)
            self.set_main_cast(current_cast)

    def remove_cast_member(self, actor_name):
        """
        Remove a single cast member from the main cast.
        """
        current_cast = self.main_cast_list
        if actor_name in current_cast:
            current_cast.remove(actor_name)
            self.set_main_cast(current_cast)

    @property
    def poster_url(self):
        """ Generate full poster URL for the movie
        """
        if self.poster_path:
            return f"https://image.tmdb.org/t/p/w500{self.poster_path}"
        return None

    @property
    def backdrop_url(self):
        """ Generate full backdrop URL for the movie
        """
        if self.backdrop_path:
            return f"https://image.tmdb.org/t/p/w500{self.backdrop_path}"
        return None


    @property
    def year(self):
        """ Extract the year from the release date
        """
        if self.release_date:
            return self.release_date.year
        return None
    
    @property
    def genre_names(self):
        """ Get a list of genre names associated with the movie
        """
        return [genre.name for genre in self.genres.all()]
    
    def increment_view_count(self):
        """ Increment the view count for the movie
        """
        Movie.objects.filter(id=self.id).update(view_count=F('view_count') + 1)
        self.refresh_from_db(fields=['view_count'])

    def increment_like_count(self):
        """ Increment the like count for the movie
        """
        Movie.objects.filter(id=self.id).update(like_count=F('like_count') + 1)
        self.refresh_from_db(fields=['like_count'])

    def calculate_our_rating(self):
        """
        Calculate a custom rating for the movie based on various factors.
        This will implement when we have user interactions
        """
        # Example calculation (this is just a placeholder)
        return (self.tmdb_rating) / 2
    
    #DJANGO MODEL METHODS
    def clean(self):
        """
        Custom validation to ensure that the release date is not in the future.
        """
        try:
            cast = json.loads(self.main_cast) if isinstance(self.main_cast, str) else self.main_cast
            if not isinstance(cast, list):
                raise ValidationError("main_cast must be a valid JSON array.")
            
            for actor in cast:
                if not isinstance(actor, str):
                    raise ValidationError("Each cast member must be a string.")
        except json.JSONDecodeError:
            raise ValidationError({
                'main_cast': "main_cast must be a valid JSON array."
            })
        
        if self.release_date and self.release_date > timezone.now().date():
            # Allow for future release dates for upcoming movies
            pass

        for rating_field in ['tmdb_rating', 'omdb_rating']:
            rating = getattr(self, rating_field)
            if rating is not None and (rating < 0 or rating > 10):
                raise ValidationError({
                    rating_field: 'Rating must be between 0.0 and 10.0'
                })
            
    def save(self, *args, **kwargs):
        self.full_clean()

        if self.our_rating is None:
            self.our_rating = self.calculate_our_rating()

        # Call parent save method..
        super().save(*args, **kwargs)


    def __str__(self):
        """
        String representation of the Movie Model
        """
        year_str = f"({self.year})" if self.year else ""
        return f"{self.title}{year_str}"
    
    def __repr__(self):
        """
        Developer representation of the Movie model.
        """
        return f"Movie(tmdb_id={self.tmdb_id}, title={self.title}, release_date={self.release_date})"
    
class MovieGenre(models.Model):
    """
    This represents the table with many to many relationships between movies and genres
    
    """

    # Foreig key to movie_table
    movie = models.ForeignKey(
        Movie,
        on_delete = models.CASCADE,
        related_name='movie_genres',
        help_text = 'Movie in this relationship'
    )
    genre = models.ForeignKey(
        Genre,
        on_delete = models.CASCADE,
        related_name = 'movie_genres',
        help_text = 'Genre in this relationship'
    )

    class Meta:
        db_table = 'movie_genres'
        verbose_name = "Movie Genre"
        verbose_name_plural = "Movie Genres"

        # Unique constraint to ensure a movie can only have a genre once
        constraints = [
            models.UniqueConstraint(fields=['movie', 'genre'], name='unique_movie_genre')
        ]

        # Indexes for performance optimization
        indexes = [
            models.Index(fields=['movie'], name='idx_movie_genre_movie'),
            models.Index(fields=['genre'], name='idx_movie_genre_genre'),
        ]

    def __str__(self):
        """
        String representation of the MovieGenre Model
        """
        return f"{self.movie.title} - {self.genre.name}"
    
    def __repr__(self):
        """
        Developer representation of the MovieGenre model.
        """
        return f"MovieGenre(movie={self.movie.title}, genre={self.genre.name})"
    
# MODEL MANAGERS (Optional - for custom querysets)
class MovieManager(models.Manager):
    """
    Custom manager for the Movie model to add custom query methods.
    """
    def popular_movies(self, limit=10):
        """
        Get the most popular movies based on the popularity score.
        """
        return self.get_queryset().order_by('-popularity_score')[:limit]

    def top_rated(self):
        """
        Get the top-rated movies based on the TMDB rating.
        """
        return self.get_queryset().filter(tmdb_rating__gte=7.0).order_by('-tmdb_rating')


    def recent(self, limit=10):
        """
        Get the most recent movie releases.
        """
        two_years_ago = lambda: date.today() - timedelta(days=730)
        return self.get_queryset().filter(
            release_date__gte=two_years_ago()
        ).order_by('-release_date')

    def by_genre(self, genre_name):
        """
        Get movies by genre name.
        """
        return self.get_queryset().filter(genres__name__iexact=genre_name).distinct()
    
    def search(self, query):
        """
        Search movies by title or overview.
        """
        from django.db.models import Q
        return self.get_queryset().filter(
            Q(title__icontains=query) | Q(overview__icontains=query)
        )   
    
# Add custom manager to the Movie model
Movie.add_to_class('objects', MovieManager())